import { useEffect, useRef, useState, useCallback } from 'react'
import Hls from 'hls.js'
import { Play, Pause } from 'lucide-react'

export default function HLSPlayer({ 
  src, 
  onTimeUpdate, 
  autoplay = true,
  className = '',
  onLoadedData,
  onEnded 
}) {
  const videoRef = useRef(null)
  const hlsRef = useRef(null)
  const [isPlaying, setIsPlaying] = useState(false)
  const [isLoaded, setIsLoaded] = useState(false)
  const [watchedTime, setWatchedTime] = useState(0)
  const [showControls, setShowControls] = useState(false)
  const [isMobile, setIsMobile] = useState(false)
  const [loadError, setLoadError] = useState(null)
  const [retryCount, setRetryCount] = useState(0)
  const timeUpdateIntervalRef = useRef(null)
  const lastReportedSecond = useRef(-1)
  const lastSavedSecond = useRef(-1)
  const controlsTimeoutRef = useRef(null)
  const storageKey = `hls-player-time-${btoa(src).slice(0, 20)}` // Chave única baseada na URL

  // Carregar tempo salvo do localStorage
  const loadSavedTime = useCallback(() => {
    try {
      const savedTime = localStorage.getItem(storageKey)
      return savedTime ? parseFloat(savedTime) : 0
    } catch (error) {
      console.warn('Erro ao carregar tempo do localStorage:', error)
      return 0
    }
  }, [storageKey])

  // Salvar tempo no localStorage
  const saveTimeToStorage = useCallback((time) => {
    try {
      localStorage.setItem(storageKey, time.toString())
    } catch (error) {
      console.warn('Erro ao salvar tempo no localStorage:', error)
    }
  }, [storageKey])

  // Limpar tempo salvo do localStorage
  const clearSavedTime = useCallback(() => {
    try {
      localStorage.removeItem(storageKey)
    } catch (error) {
      console.warn('Erro ao limpar tempo do localStorage:', error)
    }
  }, [storageKey])

  // Detectar dispositivo móvel
  useEffect(() => {
    const checkIsMobile = () => {
      const userAgent = navigator.userAgent || navigator.vendor || window.opera
      const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0
      setIsMobile(isMobileDevice || isTouchDevice)
      
      // Em mobile, mostrar controles por padrão
      if (isMobileDevice || isTouchDevice) {
        setShowControls(true)
      }
    }
    
    checkIsMobile()
    window.addEventListener('resize', checkIsMobile)
    
    return () => window.removeEventListener('resize', checkIsMobile)
  }, [])

  // Gerenciar timeout dos controles
  const hideControlsAfterDelay = useCallback(() => {
    if (isMobile) return // Em mobile, sempre mostrar controles
    
    if (controlsTimeoutRef.current) {
      clearTimeout(controlsTimeoutRef.current)
    }
    
    controlsTimeoutRef.current = setTimeout(() => {
      setShowControls(false)
    }, 3000) // 3 segundos
  }, [isMobile])

  // Mostrar controles
  const showControlsHandler = useCallback(() => {
    setShowControls(true)
    hideControlsAfterDelay()
  }, [hideControlsAfterDelay])

  // Retry mechanism
  const retryLoad = useCallback(() => {
    if (retryCount < 3) {
      setLoadError(null)
      setIsLoaded(false)
      setRetryCount(prev => prev + 1)
      
      // Force re-initialization
      const video = videoRef.current
      if (video) {
        video.src = ''
        video.load()
      }
      
      setTimeout(() => {
        // Trigger useEffect to reinitialize
        if (hlsRef.current) {
          hlsRef.current.destroy()
          hlsRef.current = null
        }
      }, 100)
    }
  }, [retryCount])

  // Função para controlar o tempo assistido - OTIMIZADA + PERSISTÊNCIA
  const startTimeTracking = useCallback(() => {
    if (timeUpdateIntervalRef.current) return
    
    timeUpdateIntervalRef.current = setInterval(() => {
      if (videoRef.current && !videoRef.current.paused) {
        const currentTime = videoRef.current.currentTime
        const currentSecond = Math.floor(currentTime)
        
        // Só atualiza se mudou de segundo para reduzir chamadas
        if (currentSecond > lastReportedSecond.current) {
          lastReportedSecond.current = currentSecond
          
          setWatchedTime(prev => {
            const newTime = Math.max(prev, currentTime)
            
            // Salva no localStorage a cada 4 segundos
            if (currentSecond % 4 === 0 && currentSecond > lastSavedSecond.current) {
              lastSavedSecond.current = currentSecond
              saveTimeToStorage(newTime)
            }
            
            // Só chama onTimeUpdate a cada segundo novo
            if (onTimeUpdate) {
              onTimeUpdate(newTime, videoRef.current.duration || 0)
            }
            
            return newTime
          })
        }
      }
    }, 500) // Reduzido para 500ms - menos overhead
  }, [onTimeUpdate, saveTimeToStorage])

  const stopTimeTracking = useCallback(() => {
    if (timeUpdateIntervalRef.current) {
      clearInterval(timeUpdateIntervalRef.current)
      timeUpdateIntervalRef.current = null
    }
  }, [])

  // Inicializar HLS - CORRIGIDO
  useEffect(() => {
    const video = videoRef.current
    if (!video || !src) return

    let isMounted = true
    let hlsInstance = null

    const initializePlayer = async () => {
      try {
        if (Hls.isSupported()) {
          hlsInstance = new Hls({
            enableWorker: false,
            lowLatencyMode: true,
            backBufferLength: 90,
            maxBufferLength: 600,
            maxMaxBufferLength: 1200,
            maxBufferSize: 60 * 1000 * 1000,
            maxBufferHole: 0.5,
          })

          hlsRef.current = hlsInstance
          hlsInstance.loadSource(src)
          hlsInstance.attachMedia(video)

          hlsInstance.on(Hls.Events.MANIFEST_PARSED, async () => {
            if (!isMounted) return
            
            setIsLoaded(true)
            if (onLoadedData) onLoadedData()
            
            // Aguardar um pouco para o vídeo estar pronto
            await new Promise(resolve => setTimeout(resolve, 100))
            
            if (!isMounted) return
            
            // Restaurar tempo salvo
            const savedTime = loadSavedTime()
            if (savedTime > 0) {
              video.currentTime = savedTime
              setWatchedTime(savedTime)
            }
            
            if (autoplay && isMounted) {
              try {
                await video.play()
                if (isMounted) {
                  setIsPlaying(true)
                  startTimeTracking()
                }
              } catch (playError) {
                // Erro silencioso para autoplay bloqueado
                if (playError.name !== 'AbortError') {
                  console.warn('Autoplay falhou:', playError.message)
                }
              }
            }
          })

          hlsInstance.on(Hls.Events.ERROR, (event, data) => {
            console.error('HLS Error:', data)
            if (data.fatal) {
              switch (data.type) {
                case Hls.ErrorTypes.NETWORK_ERROR:
                  console.error('HLS Network Error:', data)
                  if (retryCount < 3) {
                    setTimeout(() => retryLoad(), 1000)
                  } else {
                    setLoadError('Erro de rede. Verifique sua conexão.')
                  }
                  break
                case Hls.ErrorTypes.MEDIA_ERROR:
                  console.error('HLS Media Error:', data)
                  try {
                    hlsInstance.recoverMediaError()
                  } catch (err) {
                    if (retryCount < 3) {
                      setTimeout(() => retryLoad(), 1000)
                    } else {
                      setLoadError('Erro ao carregar o vídeo.')
                    }
                  }
                  break
                default:
                  if (retryCount < 3) {
                    setTimeout(() => retryLoad(), 1000)
                  } else {
                    setLoadError('Erro inesperado ao carregar o vídeo.')
                  }
                  break
              }
            }
          })

        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
          // Safari nativo HLS
          const handleLoadedData = async () => {
            if (!isMounted) return
            
            setIsLoaded(true)
            if (onLoadedData) onLoadedData()
            
            // Aguardar um pouco para o vídeo estar pronto
            await new Promise(resolve => setTimeout(resolve, 100))
            
            if (!isMounted) return
            
            // Restaurar tempo salvo
            const savedTime = loadSavedTime()
            if (savedTime > 0) {
              video.currentTime = savedTime
              setWatchedTime(savedTime)
            }
            
            if (autoplay && isMounted) {
              try {
                await video.play()
                if (isMounted) {
                  setIsPlaying(true)
                  startTimeTracking()
                }
              } catch (playError) {
                // Erro silencioso para autoplay bloqueado
                if (playError.name !== 'AbortError') {
                  console.warn('Autoplay falhou:', playError.message)
                }
              }
            }
          }
          
          const handleError = () => {
            console.error('Erro ao carregar vídeo HLS nativo')
            if (retryCount < 3) {
              setTimeout(() => retryLoad(), 1000)
            } else {
              setLoadError('Erro ao carregar o vídeo.')
            }
          }
          
          video.src = src
          video.addEventListener('loadeddata', handleLoadedData, { once: true })
          video.addEventListener('error', handleError, { once: true })
        } else {
          setLoadError('Seu navegador não suporta a reprodução deste vídeo.')
        }
      } catch (error) {
        console.error('Erro ao inicializar player:', error)
        if (retryCount < 3) {
          setTimeout(() => retryLoad(), 1000)
        } else {
          setLoadError('Erro ao inicializar o player de vídeo.')
        }
      }
    }

    initializePlayer()

    return () => {
      isMounted = false
      stopTimeTracking()
      
      // Salvar tempo final antes de destruir
      if (video && watchedTime > 0) {
        saveTimeToStorage(watchedTime)
      }
      
      if (hlsInstance) {
        hlsInstance.destroy()
        hlsInstance = null
      }
      hlsRef.current = null
    }
  }, [src])

  // Event listeners do vídeo
  useEffect(() => {
    const video = videoRef.current
    if (!video) return

    const handlePlay = () => {
      setIsPlaying(true)
      startTimeTracking()
    }

    const handlePause = () => {
      setIsPlaying(false)
      stopTimeTracking()
    }

    const handleEnded = () => {
      setIsPlaying(false)
      stopTimeTracking()
      // Limpar localStorage quando o vídeo terminar
      clearSavedTime()
      if (onEnded) onEnded()
    }

    video.addEventListener('play', handlePlay)
    video.addEventListener('pause', handlePause)
    video.addEventListener('ended', handleEnded)

    return () => {
      video.removeEventListener('play', handlePlay)
      video.removeEventListener('pause', handlePause)
      video.removeEventListener('ended', handleEnded)
    }
  }, [startTimeTracking, stopTimeTracking, onEnded])

  const togglePlayPause = (e) => {
    // Prevenir propagação para evitar duplo clique
    if (e) {
      e.preventDefault()
      e.stopPropagation()
    }
    
    const video = videoRef.current
    if (!video || !isLoaded) return

    // Se o vídeo terminou (está no final), resetar para o início
    if (video.ended) {
      video.currentTime = 0
      setWatchedTime(0)
      clearSavedTime()
      lastReportedSecond.current = -1
      lastSavedSecond.current = -1
    }

    // Usar o estado atual do vídeo, não o estado React para decisão
    if (video.paused || video.ended) {
      video.play().catch(console.error)
    } else {
      setLoadError('Erro ao carregar o vídeo.')
    }
  }
  
  video.src = src
  video.addEventListener('loadeddata', handleLoadedData, { once: true })
  video.addEventListener('error', handleError, { once: true })
} else {
  setLoadError('Seu navegador não suporta a reprodução deste vídeo.')
}

} catch (error) {
  console.error('Erro ao inicializar player:', error)
  if (retryCount < 3) {
    setTimeout(() => retryLoad(), 1000)
  } else {
    setLoadError('Erro ao inicializar o player de vídeo.')
  }
}

initializePlayer()

return () => {
  isMounted = false
  stopTimeTracking()
  
  // Salvar tempo final antes de destruir
  if (video && watchedTime > 0) {
    saveTimeToStorage(watchedTime)
  }
  
  if (hlsInstance) {
    hlsInstance.destroy()
    hlsInstance = null
  }
  hlsRef.current = null
}

// Event listeners do vídeo
useEffect(() => {
  const video = videoRef.current
  if (!video) return

  const handlePlay = () => {
    setIsPlaying(true)
    startTimeTracking()
  }

  const handlePause = () => {
    setIsPlaying(false)
    stopTimeTracking()
  }

  const handleEnded = () => {
    setIsPlaying(false)
    stopTimeTracking()
    // Limpar localStorage quando o vídeo terminar
    clearSavedTime()
    if (onEnded) onEnded()
  }

  video.addEventListener('play', handlePlay)
  video.addEventListener('pause', handlePause)
  video.addEventListener('ended', handleEnded)

  return () => {
    video.removeEventListener('play', handlePlay)
    video.removeEventListener('pause', handlePause)
    video.removeEventListener('ended', handleEnded)
  }
}, [startTimeTracking, stopTimeTracking, onEnded])

const togglePlayPause = (e) => {
  // Prevenir propagação para evitar duplo clique
  if (e) {
    e.preventDefault()
    e.stopPropagation()
  }
  
  const video = videoRef.current
  if (!video || !isLoaded) return

  // Se o vídeo terminou (está no final), resetar para o início
  if (video.ended) {
    video.currentTime = 0
    setWatchedTime(0)
    clearSavedTime()
    lastReportedSecond.current = -1
    lastSavedSecond.current = -1
  }

  // Usar o estado atual do vídeo, não o estado React para decisão
  if (video.paused || video.ended) {
    video.play().catch(console.error)
  } else {
    video.pause()
  }
}

return (
  <div className={`relative ${className}`}
       onMouseEnter={!isMobile ? showControlsHandler : undefined}
       onMouseMove={!isMobile ? showControlsHandler : undefined}
       onMouseLeave={!isMobile ? () => hideControlsAfterDelay() : undefined}
       onTouchStart={isMobile ? showControlsHandler : undefined}>
    {/* Vídeo */}
    <video
      ref={videoRef}
      className="w-full h-full object-cover rounded-lg"
      playsInline
      muted={false}
      preload="metadata"
    />
    
    {/* Overlay com controles - clicável */}
    <div 
      className={`absolute inset-0 transition-all duration-300 rounded-lg flex items-center justify-center cursor-pointer ${
        showControls || !isLoaded || loadError ? 'bg-black/20' : 'bg-transparent'
      }`}
      onClick={togglePlayPause}
    >
      {/* Botão Play/Pause centralizado */}
      <div
        className={`
          bg-black/70 text-white rounded-full p-4 
          transition-all duration-200 transform active:scale-95 pointer-events-none
          ${!isLoaded ? 'opacity-50' : ''}
          ${loadError ? 'hidden' : ''}
          ${showControls || isMobile || !isPlaying ? 'opacity-100 scale-100' : 'opacity-0 scale-90'}
        `}
      >
        {isPlaying ? (
          <Pause className="w-8 h-8" />
        ) : (
          <Play className="w-8 h-8 ml-1" />
        )}
      </div>
    </div>

    {/* Indicador de carregamento */}
    {!isLoaded && !loadError && (
      <div className="absolute inset-0 bg-gray-900 rounded-lg flex items-center justify-center">
        <div className="flex flex-col items-center gap-4">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white"></div>
          {retryCount > 0 && (
            <p className="text-white text-sm">Tentativa {retryCount}/3...</p>
          )}
        </div>
      </div>
    )}

    {/* Tela de erro */}
    {loadError && (
      <div className="absolute inset-0 bg-gray-900 rounded-lg flex items-center justify-center">
        <div className="text-center text-white p-6">
          <div className="text-red-400 mb-4">
            <svg className="w-16 h-16 mx-auto" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z" />
            </svg>
          </div>
          <h3 className="text-lg font-semibold mb-2">Erro ao carregar vídeo</h3>
          <p className="text-sm text-gray-300 mb-4">{loadError}</p>
          {retryCount < 3 && (
            <button 
              onClick={retryLoad}
              className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm font-medium transition-colors"
            >
              Tentar novamente
            </button>
          )}
        </div>
      </div>
    )}
  
  </div>
)
